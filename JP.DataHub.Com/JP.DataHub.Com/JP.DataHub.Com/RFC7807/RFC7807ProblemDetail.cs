using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;

namespace JP.DataHub.Com.RFC7807
{
    public class RFC7807ProblemDetail
    {
        //
        // 概要:
        //     The default "type" value if not explicitly set. According to the RFC, this is
        //     mainly intended for scenarios where the "status" HTTP status code is sufficient
        //     to explain the problem.
        //[IgnoreDataMember]
        [JsonIgnore]
        public static readonly Uri DefaultType;

        //
        // 概要:
        //     Default constructor for when you plan to build up the object manually.
        public RFC7807ProblemDetail()
        {
            Status = (int)HttpStatusCode.OK;
        }

        //
        // 概要:
        //     Constructor taking only the HTTP status code, and setting Type and Title to appropriate
        //     values per the RFC
        public RFC7807ProblemDetail(HttpStatusCode httpStatus)
        {
            Status = (int)httpStatus;
        }

        //
        // 概要:
        //     Minimal constructor taking only the HTTP status code and the Type URI
        public RFC7807ProblemDetail(HttpStatusCode httpStatus, Uri type)
        {
            Status = (int)httpStatus;
            Type = type;
        }

        //
        // 概要:
        //     From RFC7807: A URI reference [RFC3986] that identifies the problem type. This
        //     specification encourages that, when dereferenced, it provide human-readable documentation
        //     for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member
        //     is not present, its value is assumed to be "about:blank".
        //
        // 注釈:
        //     Except for the sole case where the HTTP status code is the only information being
        //     given, you should consider the Type property as a required element since this
        //     _is_ the machine-readable problem description. This is also the namespace for
        //     extensions, i.e. an extension member name is specific to the problem Type value.
        //[DataMember(Name = "type", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "type", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Type { get; set; }

        //
        // 概要:
        //     From RFC7807: A short, human-readable summary of the problem type. It SHOULD
        //     NOT change from occurrence to occurrence of the problem, except for purposes
        //     of localization (e.g., using proactive content negotiation; see[RFC7231], Section
        //     3.4).
        //[DataMember(Name = "title", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }

        //
        // 概要:
        //     From RFC7807: The HTTP status code ([RFC7231], Section 6) generated by the origin
        //     server for this occurrence of the problem.
        //
        // 注釈:
        //     Setting the original http status in the problem data means the caller can still
        //     retrieve it even if any intermediate proxies have stripped off the original status
        //     code from the response.
        //[DataMember(Name = "status")]
        [JsonProperty(PropertyName = "status", NullValueHandling = NullValueHandling.Ignore)]
        public int Status { get; set; }

        //
        // 概要:
        //     From RFC7807: A human-readable explanation specific to this occurrence of the
        //     problem. If present, ought to focus on helping the client correct the problem,
        //     rather than giving debugging information.
        //[DataMember(Name = "detail", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "detail", NullValueHandling = NullValueHandling.Ignore)]
        public string Detail { get; set; }

        //
        // 概要:
        //     From RFC7807: A URI reference that identifies the specific occurrence of the
        //     problem. It may or may not yield further information if dereferenced.
        //[DataMember(Name = "instance", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "instance", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Instance { get; set; }

        //
        // 概要:
        //     From RFC7807: A problem type definition MAY specify additional members on the
        //     problem details object. For example, an extension might use typed links[RFC5988]
        //     to another resource that can be used by machines to resolve the problem. If such
        //     additional members are defined, their names SHOULD start with a letter (ALPHA,
        //     as per[RFC5234], Appendix B.1) and SHOULD consist of characters from ALPHA, DIGIT([RFC5234],
        //     Appendix B.1), and "_" (so that it can be serialized in formats other than JSON),
        //     and they SHOULD be three characters or longer.
        //
        // 注釈:
        //     In this implementation, all custom extensions will appear as children under a
        //     parent property named "extensions". Example: "extensions": { "balance": 30, "accounts":
        //     [ "/account/12345", "/account/67890" ] }
        //[DataMember(Name = "extensions", EmitDefaultValue = false)]
        //[Dynamic(new[] { false, false, true })]
        [JsonProperty(PropertyName = "extensions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Extensions { get; set; }

        //[DataMember(Name = "error_code", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "error_code", NullValueHandling = NullValueHandling.Ignore)]
        public string ErrorCode { get; set; }

        //[DataMember(Name = "errors", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "errors", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, string[]> Errors { get; set; }
    }
}
